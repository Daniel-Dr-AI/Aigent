{
  "name": "Aigent Module 06 - Document Capture & OCR",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "aigent-document-capture",
        "responseMode": "responseNode",
        "options": {
          "allowedOrigins": "={{$env.ALLOWED_ORIGINS || '*'}}"
        }
      },
      "id": "601",
      "name": "Webhook - Document Upload",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [250, 300],
      "webhookId": "{{$env.WEBHOOK_ID_MODULE_06}}",
      "notes": "Primary entry point: accepts multipart/form-data with file + optional metadata JSON"
    },
    {
      "parameters": {
        "jsCode": "// Identify document source and extract metadata\nconst input = $input.item;\nconst traceId = input.json.body?.trace_id || `DOC-${Date.now()}`;\n\n// Handle different input sources\nlet file, meta, source;\n\n// Webhook upload (multipart)\nif (input.binary && input.binary.data) {\n  file = input.binary.data;\n  meta = input.json.body || {};\n  source = 'webhook';\n}\n// S3/Drive watch (from storage node)\nelse if (input.json.file_path) {\n  file = input.binary?.file || null;\n  meta = input.json.metadata || {};\n  source = input.json.source || 's3';\n}\n// Email attachment (from IMAP)\nelse if (input.json.email) {\n  file = input.binary?.attachment || null;\n  meta = {\n    patient_email: input.json.email.from,\n    subject: input.json.email.subject\n  };\n  source = 'email';\n}\nelse {\n  throw new Error('No valid file input detected');\n}\n\n// Validate file exists\nif (!file) {\n  throw new Error('File data not found in input');\n}\n\n// Extract metadata\nconst fileName = file.fileName || meta.filename || 'unknown.pdf';\nconst mimeType = file.mimeType || meta.mime_type || 'application/pdf';\nconst fileSize = file.fileSize || file.data?.length || 0;\n\n// Infer doc_type from filename or metadata\nlet docType = meta.doc_type || $env.DOC_TYPE_FALLBACK || 'other';\nif (!meta.doc_type) {\n  const nameLower = fileName.toLowerCase();\n  if (nameLower.includes('lab') || nameLower.includes('result')) docType = 'lab_result';\n  else if (nameLower.includes('intake') || nameLower.includes('form')) docType = 'intake_form';\n  else if (nameLower.includes('id') || nameLower.includes('card')) docType = 'id_card';\n  else if (nameLower.includes('invoice') || nameLower.includes('bill')) docType = 'invoice';\n  else if (nameLower.includes('insurance')) docType = 'insurance_card';\n  else if (nameLower.includes('consent')) docType = 'consent_form';\n}\n\nreturn {\n  json: {\n    trace_id: traceId,\n    source: source,\n    doc_type: docType,\n    file: {\n      name: fileName,\n      mime_type: mimeType,\n      size_bytes: fileSize,\n      size_mb: (fileSize / 1024 / 1024).toFixed(2)\n    },\n    patient: {\n      name: meta.patient_name || null,\n      email: meta.patient_email || null,\n      external_id: meta.patient_id || null\n    },\n    capture_ts: meta.capture_ts || new Date().toISOString(),\n    approved_sources: ($env.APPROVED_SOURCE_LIST || 'webhook,s3,gdrive,email').split(','),\n    hipaa_mode: $env.HIPAA_MODE === 'true'\n  },\n  binary: {\n    data: file\n  }\n};"
      },
      "id": "602",
      "name": "Identify Document & Extract Metadata",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [450, 300],
      "notes": "Parse input source, infer doc_type, extract patient metadata, prepare for validation"
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{$json.approved_sources.includes($json.source)}}",
              "value2": true
            },
            {
              "value1": "={{parseFloat($json.file.size_mb) <= parseFloat($env.MAX_FILE_MB || 15)}}",
              "value2": true
            },
            {
              "value1": "={{($env.ALLOWED_MIME || 'application/pdf,image/jpeg,image/png').split(',').includes($json.file.mime_type)}}",
              "value2": true
            }
          ]
        }
      },
      "id": "603",
      "name": "Validate Source, Size & MIME Type",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [650, 300],
      "notes": "PHI Guard: verify source is approved, file size <= MAX_FILE_MB, MIME type is allowed"
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={\"success\": false, \"error\": \"Validation failed: invalid source, file too large, or unsupported MIME type\", \"stage\": \"validation\", \"trace_id\": \"{{$json.trace_id}}\", \"details\": { \"source\": \"{{$json.source}}\", \"size_mb\": \"{{$json.file.size_mb}}\", \"mime\": \"{{$json.file.mime_type}}\" }}",
        "options": {
          "responseCode": 400
        }
      },
      "id": "604",
      "name": "Return Validation Error",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [850, 450],
      "notes": "Return 400 error if validation fails"
    },
    {
      "parameters": {
        "mode": "jsonOutput",
        "jsonOutput": "={{ { \"ocr_engine\": $env.OCR_ENGINE || 'mistral' } }}"
      },
      "id": "605",
      "name": "Select OCR Engine",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.2,
      "position": [850, 300],
      "notes": "Read OCR_ENGINE from env (mistral|gemini|abbyy|tesseract)"
    },
    {
      "parameters": {
        "conditions": {
          "string": [
            {
              "value1": "={{$json.ocr_engine}}",
              "value2": "mistral"
            }
          ]
        }
      },
      "id": "606",
      "name": "Switch: Mistral OCR",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [1050, 200],
      "notes": "Route to Mistral OCR if engine = mistral"
    },
    {
      "parameters": {
        "conditions": {
          "string": [
            {
              "value1": "={{$json.ocr_engine}}",
              "value2": "gemini"
            }
          ]
        }
      },
      "id": "607",
      "name": "Switch: Gemini Vision",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [1050, 300],
      "notes": "Route to Google Gemini if engine = gemini"
    },
    {
      "parameters": {
        "conditions": {
          "string": [
            {
              "value1": "={{$json.ocr_engine}}",
              "value2": "abbyy"
            }
          ]
        }
      },
      "id": "608",
      "name": "Switch: ABBYY Cloud",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [1050, 400],
      "notes": "Route to ABBYY Cloud OCR if engine = abbyy"
    },
    {
      "parameters": {
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "url": "https://api.mistral.ai/v1/ocr",
        "method": "POST",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "Bearer {{$env.MISTRAL_OCR_API_KEY}}"
            },
            {
              "name": "Content-Type",
              "value": "multipart/form-data"
            }
          ]
        },
        "sendBody": true,
        "contentType": "multipart-form-data",
        "bodyParameters": {
          "parameters": [
            {
              "name": "file",
              "inputDataFieldName": "={{$binary.data}}"
            },
            {
              "name": "language",
              "value": "={{$env.OCR_LANGUAGE || 'eng'}}"
            },
            {
              "name": "output_format",
              "value": "json"
            }
          ]
        },
        "options": {}
      },
      "id": "609",
      "name": "Mistral OCR API",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [1250, 150],
      "notes": "Call Mistral OCR API with uploaded file; returns structured JSON"
    },
    {
      "parameters": {
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "url": "https://generativelanguage.googleapis.com/v1beta/models/gemini-pro-vision:generateContent",
        "method": "POST",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "Bearer {{$env.GEMINI_API_KEY}}"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "contents",
              "value": "={{ [{ \"parts\": [{ \"text\": \"Extract all text and structured data from this document. Return as JSON with fields: text, date_of_service, provider, patient_name, values[]\" }, { \"inline_data\": { \"mime_type\": $json.file.mime_type, \"data\": $binary.data.data.toString('base64') } }] }] }}"
            }
          ]
        },
        "options": {}
      },
      "id": "610",
      "name": "Google Gemini Vision API",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [1250, 250],
      "notes": "Call Google Gemini with vision prompt for OCR + structured extraction"
    },
    {
      "parameters": {
        "authentication": "genericCredentialType",
        "genericAuthType": "httpBasicAuth",
        "url": "https://cloud-eu.abbyy.com/v2/processImage",
        "method": "POST",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/octet-stream"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "language",
              "value": "={{$env.OCR_LANGUAGE || 'English'}}"
            },
            {
              "name": "exportFormat",
              "value": "txtUnstructured"
            }
          ]
        },
        "options": {}
      },
      "id": "611",
      "name": "ABBYY Cloud OCR API",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [1250, 350],
      "notes": "Call ABBYY Cloud OCR; requires basic auth with ABBYY_APP_ID:ABBYY_APP_PASSWORD",
      "credentials": {
        "httpBasicAuth": {
          "id": "{{$env.ABBYY_CREDENTIAL_ID}}",
          "name": "ABBYY Basic Auth"
        }
      }
    },
    {
      "parameters": {
        "command": "={{$env.TESSERACT_CMD || '/usr/bin/tesseract'}} {{$binary.data.fileName}} stdout -l {{$env.OCR_LANGUAGE || 'eng'}} --oem 3 --psm 6",
        "options": {}
      },
      "id": "612",
      "name": "Tesseract OCR (Self-Hosted)",
      "type": "n8n-nodes-base.executeCommand",
      "typeVersion": 1,
      "position": [1250, 450],
      "notes": "Run Tesseract locally; requires tesseract binary installed on host"
    },
    {
      "parameters": {
        "jsCode": "// Normalize OCR output from different engines\nconst engine = $json.ocr_engine || $env.OCR_ENGINE || 'mistral';\nlet extractedText = '';\nlet confidence = 0.0;\nlet structuredData = {};\n\ntry {\n  if (engine === 'mistral') {\n    // Mistral OCR returns { text, confidence, fields }\n    const response = $input.item.json;\n    extractedText = response.text || response.content || '';\n    confidence = response.confidence || 0.9;\n    structuredData = response.fields || {};\n  }\n  else if (engine === 'gemini') {\n    // Gemini returns { candidates[].content.parts[].text }\n    const response = $input.item.json;\n    const candidate = response.candidates?.[0];\n    const textPart = candidate?.content?.parts?.[0]?.text || '';\n    extractedText = textPart;\n    // Try to parse as JSON if Gemini returned structured data\n    try {\n      structuredData = JSON.parse(textPart);\n      extractedText = structuredData.text || textPart;\n    } catch (e) {\n      // Plain text only\n    }\n    confidence = candidate?.finishReason === 'STOP' ? 0.85 : 0.7;\n  }\n  else if (engine === 'abbyy') {\n    // ABBYY returns plain text or XML; parse accordingly\n    const response = $input.item.json;\n    extractedText = response.text || response.toString();\n    confidence = 0.92; // ABBYY is high-quality\n  }\n  else if (engine === 'tesseract') {\n    // Tesseract stdout\n    const response = $input.item.json;\n    extractedText = response.stdout || response.output || '';\n    confidence = 0.75; // Tesseract quality varies\n  }\n}\ncatch (error) {\n  throw new Error(`OCR post-processing failed: ${error.message}`);\n}\n\n// Clean text: remove extra whitespace, normalize line breaks\nextractedText = extractedText.trim().replace(/\\r\\n/g, '\\n').replace(/\\n{3,}/g, '\\n\\n');\n\n// Merge with original metadata\nconst originalData = $input.item.json;\n\nreturn {\n  json: {\n    ...originalData,\n    ocr_result: {\n      engine: engine,\n      text: extractedText,\n      confidence: confidence,\n      char_count: extractedText.length,\n      structured: structuredData\n    }\n  },\n  binary: $input.item.binary\n};"
      },
      "id": "613",
      "name": "Post-Process OCR Output",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1450, 300],
      "notes": "Normalize OCR responses from all engines; clean text, compute confidence"
    },
    {
      "parameters": {
        "jsCode": "// Map extracted text to normalized schema based on doc_type\nconst docType = $json.doc_type || 'other';\nconst text = $json.ocr_result?.text || '';\nconst structured = $json.ocr_result?.structured || {};\n\nlet extracted = {\n  date_of_service: null,\n  provider: null,\n  values: []\n};\n\n// Date extraction regex (multiple formats)\nconst datePatterns = [\n  /(?:date|dos|service date)[:\\s]*(\\d{1,2}[\\/\\-]\\d{1,2}[\\/\\-]\\d{2,4})/i,\n  /(\\d{4}-\\d{2}-\\d{2})/,\n  /(\\d{1,2}\\/\\d{1,2}\\/\\d{4})/\n];\nfor (const pattern of datePatterns) {\n  const match = text.match(pattern);\n  if (match) {\n    extracted.date_of_service = match[1] || match[0];\n    break;\n  }\n}\n\n// Provider extraction\nconst providerPattern = /(?:provider|physician|doctor|dr\\.?)[:\\s]*([A-Z][a-z]+\\s[A-Z][a-z]+)/i;\nconst providerMatch = text.match(providerPattern);\nif (providerMatch) {\n  extracted.provider = providerMatch[1];\n}\n\n// Doc-type specific extraction\nif (docType === 'lab_result') {\n  // Extract lab values: HDL, LDL, Glucose, etc.\n  const labPatterns = [\n    { key: 'hdl', pattern: /HDL[:\\s]*(\\d+\\.?\\d*)\\s*(mg\\/dL)?/i },\n    { key: 'ldl', pattern: /LDL[:\\s]*(\\d+\\.?\\d*)\\s*(mg\\/dL)?/i },\n    { key: 'glucose', pattern: /Glucose[:\\s]*(\\d+\\.?\\d*)\\s*(mg\\/dL)?/i },\n    { key: 'a1c', pattern: /A1C[:\\s]*(\\d+\\.?\\d*)\\s*%?/i }\n  ];\n  \n  labPatterns.forEach(({ key, pattern }) => {\n    const match = text.match(pattern);\n    if (match) {\n      extracted.values.push({\n        key: key,\n        value: `${match[1]} ${match[2] || 'mg/dL'}`.trim()\n      });\n    }\n  });\n}\nelse if (docType === 'intake_form') {\n  // Extract patient demographics\n  const dobPattern = /(?:DOB|date of birth)[:\\s]*(\\d{1,2}[\\/\\-]\\d{1,2}[\\/\\-]\\d{2,4})/i;\n  const dobMatch = text.match(dobPattern);\n  if (dobMatch) {\n    extracted.values.push({ key: 'dob', value: dobMatch[1] });\n  }\n  \n  const phonePattern = /(?:phone|tel)[:\\s]*(\\(?\\d{3}\\)?[\\s\\-\\.]?\\d{3}[\\s\\-\\.]?\\d{4})/i;\n  const phoneMatch = text.match(phonePattern);\n  if (phoneMatch) {\n    extracted.values.push({ key: 'phone', value: phoneMatch[1] });\n  }\n}\nelse if (docType === 'id_card' || docType === 'insurance_card') {\n  // Extract ID numbers\n  const idPattern = /(?:ID|Member|Policy)[:\\s#]*(\\w{6,})/i;\n  const idMatch = text.match(idPattern);\n  if (idMatch) {\n    extracted.values.push({ key: 'id_number', value: idMatch[1] });\n  }\n}\n\n// Override with structured data if available\nif (structured.date_of_service) extracted.date_of_service = structured.date_of_service;\nif (structured.provider) extracted.provider = structured.provider;\nif (structured.values) extracted.values = [...extracted.values, ...structured.values];\n\nreturn {\n  json: {\n    ...$json,\n    extracted: extracted\n  },\n  binary: $binary\n};"
      },
      "id": "614",
      "name": "Map to Normalized Schema",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1650, 300],
      "notes": "Extract structured fields based on doc_type; map to standardized schema"
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{$env.REDACTION_ENABLED === 'true'}}",
              "value2": true
            }
          ]
        }
      },
      "id": "615",
      "name": "Check If Redaction Enabled",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [1850, 300],
      "notes": "If REDACTION_ENABLED=true, redact sensitive data (SSN, MRN, CC)"
    },
    {
      "parameters": {
        "jsCode": "// Redact sensitive information from OCR text\nlet text = $json.ocr_result?.text || '';\nlet redactedText = text;\n\n// SSN redaction: XXX-XX-1234 → XXX-XX-****\nredactedText = redactedText.replace(/(\\d{3}[-\\s]?\\d{2}[-\\s]?)(\\d{4})/g, '$1****');\n\n// Credit card redaction: 4111 1111 1111 1234 → **** **** **** 1234\nredactedText = redactedText.replace(/(\\d{4})[\\s\\-]?(\\d{4})[\\s\\-]?(\\d{4})[\\s\\-]?(\\d{4})/g, '**** **** **** $4');\n\n// MRN/Account number redaction: MRN: 123456789 → MRN: ****6789\nredactedText = redactedText.replace(/(?:MRN|Account|Member)[:\\s#]*(\\d+)(\\d{4})/gi, (match, p1, p2) => {\n  return match.replace(p1 + p2, '****' + p2);\n});\n\n// Email redaction: user@example.com → u***@example.com\nredactedText = redactedText.replace(/([a-zA-Z])[a-zA-Z0-9._%+-]*(@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,})/g, '$1***$2');\n\nconst redactionCount = (text.match(/\\*/g) || []).length - (($json.ocr_result?.text || '').match(/\\*/g) || []).length;\n\nreturn {\n  json: {\n    ...$json,\n    ocr_result: {\n      ...$json.ocr_result,\n      text_original: text,\n      text: redactedText,\n      redaction_applied: true,\n      redactions_count: redactionCount\n    }\n  },\n  binary: $binary\n};"
      },
      "id": "616",
      "name": "Redact Sensitive Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2050, 200],
      "notes": "Apply regex-based redaction: SSN, CC, MRN, emails partially masked"
    },
    {
      "parameters": {
        "jsCode": "// Generate unique document ID and storage paths\nconst traceId = $json.trace_id;\nconst docType = $json.doc_type;\nconst timestamp = new Date().toISOString().replace(/[:.]/g, '-');\nconst documentId = `doc_${traceId}_${timestamp}`;\n\nconst storageProvider = $env.STORAGE_PROVIDER || 's3';\nconst fileName = $json.file.name;\nconst fileExt = fileName.split('.').pop();\n\nlet storagePaths = {};\n\nif (storageProvider === 's3') {\n  const bucket = $env.S3_BUCKET;\n  const prefix = $env.S3_PREFIX || 'clinic-docs/';\n  const region = $env.S3_REGION || 'us-east-1';\n  \n  storagePaths.original_key = `${prefix}${docType}/${documentId}_original.${fileExt}`;\n  storagePaths.redacted_key = `${prefix}${docType}/${documentId}_redacted.${fileExt}`;\n  storagePaths.bucket = bucket;\n  storagePaths.region = region;\n  storagePaths.original_url = `s3://${bucket}/${storagePaths.original_key}`;\n  storagePaths.redacted_url = `s3://${bucket}/${storagePaths.redacted_key}`;\n}\nelse if (storageProvider === 'gdrive') {\n  const folderId = $env.GDRIVE_FOLDER_ID;\n  storagePaths.folder_id = folderId;\n  storagePaths.original_name = `${documentId}_original.${fileExt}`;\n  storagePaths.redacted_name = `${documentId}_redacted.${fileExt}`;\n}\n\nreturn {\n  json: {\n    ...$json,\n    document_id: documentId,\n    storage: storagePaths\n  },\n  binary: $binary\n};"
      },
      "id": "617",
      "name": "Prepare Storage Paths",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2050, 300],
      "notes": "Generate document_id and construct storage paths for S3/GDrive"
    },
    {
      "parameters": {
        "conditions": {
          "string": [
            {
              "value1": "={{$env.STORAGE_PROVIDER || 's3'}}",
              "value2": "s3"
            }
          ]
        }
      },
      "id": "618",
      "name": "Switch: S3 Storage",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [2250, 250],
      "notes": "Route to S3 upload if STORAGE_PROVIDER=s3"
    },
    {
      "parameters": {
        "operation": "upload",
        "bucketName": "={{$env.S3_BUCKET}}",
        "fileName": "={{$json.storage.original_key}}",
        "binaryData": true,
        "binaryPropertyName": "data",
        "additionalFields": {
          "acl": "={{$json.hipaa_mode ? 'private' : 'private'}}",
          "serverSideEncryption": "AES256",
          "metadata": {
            "metadataProperties": [
              {
                "name": "document_id",
                "value": "={{$json.document_id}}"
              },
              {
                "name": "doc_type",
                "value": "={{$json.doc_type}}"
              },
              {
                "name": "patient_id",
                "value": "={{$json.patient.external_id || 'unknown'}}"
              },
              {
                "name": "trace_id",
                "value": "={{$json.trace_id}}"
              }
            ]
          }
        }
      },
      "id": "619",
      "name": "Upload Original to S3",
      "type": "n8n-nodes-base.awsS3",
      "typeVersion": 1,
      "position": [2450, 200],
      "notes": "Upload original file to S3 with metadata tags",
      "credentials": {
        "aws": {
          "id": "{{$env.AWS_CREDENTIAL_ID}}",
          "name": "AWS Credentials"
        }
      }
    },
    {
      "parameters": {
        "operation": "upload",
        "bucketName": "={{$env.S3_BUCKET}}",
        "fileName": "={{$json.storage.redacted_key}}",
        "binaryData": true,
        "binaryPropertyName": "data",
        "additionalFields": {
          "acl": "private",
          "serverSideEncryption": "AES256",
          "metadata": {
            "metadataProperties": [
              {
                "name": "document_id",
                "value": "={{$json.document_id}}"
              },
              {
                "name": "redacted",
                "value": "true"
              }
            ]
          }
        }
      },
      "id": "620",
      "name": "Upload Redacted to S3 (If Enabled)",
      "type": "n8n-nodes-base.awsS3",
      "typeVersion": 1,
      "position": [2450, 300],
      "notes": "Upload redacted version if REDACTION_ENABLED=true",
      "credentials": {
        "aws": {
          "id": "{{$env.AWS_CREDENTIAL_ID}}",
          "name": "AWS Credentials"
        }
      },
      "executeOnce": false
    },
    {
      "parameters": {
        "jsCode": "// Generate signed URLs for S3 objects\nconst AWS = require('aws-sdk');\n\nconst s3 = new AWS.S3({\n  accessKeyId: $env.S3_ACCESS_KEY_ID,\n  secretAccessKey: $env.S3_SECRET_ACCESS_KEY,\n  region: $env.S3_REGION || 'us-east-1'\n});\n\nconst bucket = $json.storage.bucket;\nconst originalKey = $json.storage.original_key;\nconst redactedKey = $json.storage.redacted_key;\nconst ttl = parseInt($env.SIGNED_URL_TTL_SECONDS || 600);\n\nconst hipaaMode = $json.hipaa_mode;\nconst generateSignedUrl = hipaaMode || true; // Always use signed URLs for security\n\nlet originalUrl, redactedUrl;\n\nif (generateSignedUrl) {\n  originalUrl = s3.getSignedUrl('getObject', {\n    Bucket: bucket,\n    Key: originalKey,\n    Expires: ttl\n  });\n  \n  if ($json.ocr_result?.redaction_applied) {\n    redactedUrl = s3.getSignedUrl('getObject', {\n      Bucket: bucket,\n      Key: redactedKey,\n      Expires: ttl\n    });\n  }\n} else {\n  originalUrl = `https://${bucket}.s3.${$env.S3_REGION}.amazonaws.com/${originalKey}`;\n  if ($json.ocr_result?.redaction_applied) {\n    redactedUrl = `https://${bucket}.s3.${$env.S3_REGION}.amazonaws.com/${redactedKey}`;\n  }\n}\n\nreturn {\n  json: {\n    ...$json,\n    storage: {\n      ...$json.storage,\n      original_url: originalUrl,\n      redacted_url: redactedUrl || null,\n      signed: generateSignedUrl,\n      expires_in: ttl\n    }\n  }\n};"
      },
      "id": "621",
      "name": "Generate Signed URLs",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2650, 250],
      "notes": "Generate time-limited signed URLs for S3 objects (HIPAA compliance)"
    },
    {
      "parameters": {
        "operation": "upload",
        "folderId": "={{$env.GDRIVE_FOLDER_ID}}",
        "fileName": "={{$json.storage.original_name}}",
        "binaryData": true,
        "binaryPropertyName": "data",
        "options": {}
      },
      "id": "622",
      "name": "Upload to Google Drive",
      "type": "n8n-nodes-base.googleDrive",
      "typeVersion": 3,
      "position": [2450, 400],
      "notes": "Upload to Google Drive if STORAGE_PROVIDER=gdrive",
      "credentials": {
        "googleDriveOAuth2Api": {
          "id": "={{$env.GDRIVE_CREDENTIAL_ID}}",
          "name": "Google Drive OAuth2"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{$env.EHR_SYNC_ENABLED === 'true'}}",
              "value2": true
            }
          ]
        }
      },
      "id": "623",
      "name": "Check If EHR Sync Enabled",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [2850, 200],
      "notes": "Route to EHR sync if EHR_SYNC_ENABLED=true"
    },
    {
      "parameters": {
        "conditions": {
          "string": [
            {
              "value1": "={{$env.EHR_TARGET || 'drchrono'}}",
              "value2": "drchrono"
            }
          ]
        }
      },
      "id": "624",
      "name": "Switch: DrChrono EHR",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [3050, 150],
      "notes": "Route to DrChrono if EHR_TARGET=drchrono"
    },
    {
      "parameters": {
        "authentication": "genericCredentialType",
        "genericAuthType": "oAuth2Api",
        "url": "https://app.drchrono.com/api/clinical_notes",
        "method": "POST",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "Bearer {{$env.DRCHRONO_TOKEN}}"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "patient",
              "value": "={{$json.patient.external_id}}"
            },
            {
              "name": "date",
              "value": "={{$json.extracted.date_of_service || $json.capture_ts}}"
            },
            {
              "name": "description",
              "value": "Uploaded document: {{$json.doc_type}} - {{$json.document_id}}"
            },
            {
              "name": "document_url",
              "value": "={{$json.storage.original_url}}"
            }
          ]
        },
        "options": {}
      },
      "id": "625",
      "name": "DrChrono - Attach Document",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [3250, 100],
      "notes": "Create clinical note in DrChrono with document reference",
      "continueOnFail": true
    },
    {
      "parameters": {
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "url": "https://api.redoxengine.com/endpoint",
        "method": "POST",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "Bearer {{$env.REDOX_API_KEY}}"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "Meta",
              "value": "={{ { \"DataModel\": \"Media\", \"EventType\": \"New\", \"EventDateTime\": $json.capture_ts } }}"
            },
            {
              "name": "Patient",
              "value": "={{ { \"Identifiers\": [{ \"ID\": $json.patient.external_id, \"IDType\": \"MRN\" }] } }}"
            },
            {
              "name": "Media",
              "value": "={{ { \"FileType\": $json.file.mime_type, \"FileName\": $json.file.name, \"FileContents\": $json.storage.original_url, \"DocumentType\": $json.doc_type } }}"
            }
          ]
        },
        "options": {}
      },
      "id": "626",
      "name": "Redox - Send Media Event",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [3250, 200],
      "notes": "Send document to EHR via Redox interoperability platform",
      "continueOnFail": true
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{$env.CRM_SYNC_ENABLED === 'true'}}",
              "value2": true
            }
          ]
        }
      },
      "id": "627",
      "name": "Check If CRM Sync Enabled",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [2850, 400],
      "notes": "Route to CRM sync if CRM_SYNC_ENABLED=true"
    },
    {
      "parameters": {
        "authentication": "oAuth2",
        "resource": "contact",
        "operation": "upsert",
        "email": "={{$json.patient.email}}",
        "additionalFields": {
          "properties": {
            "property": [
              {
                "name": "last_document_upload",
                "value": "={{$json.capture_ts}}"
              },
              {
                "name": "last_document_type",
                "value": "={{$json.doc_type}}"
              },
              {
                "name": "document_url",
                "value": "={{$json.storage.redacted_url || $json.storage.original_url}}"
              },
              {
                "name": "document_count",
                "value": "={{($json.document_count || 0) + 1}}"
              }
            ]
          }
        }
      },
      "id": "628",
      "name": "HubSpot - Update Contact",
      "type": "n8n-nodes-base.hubspot",
      "typeVersion": 2,
      "position": [3050, 350],
      "notes": "Update HubSpot contact with document metadata and link",
      "credentials": {
        "hubspotOAuth2Api": {
          "id": "{{$env.HUBSPOT_CREDENTIAL_ID}}",
          "name": "HubSpot OAuth2"
        }
      },
      "continueOnFail": true
    },
    {
      "parameters": {
        "authentication": "oAuth2",
        "resource": "attachment",
        "operation": "create",
        "sobjectType": "Contact",
        "recordId": "={{$json.crm_contact_id}}",
        "name": "={{$json.file.name}}",
        "binaryPropertyName": "data",
        "additionalFields": {
          "description": "Document upload: {{$json.doc_type}} - {{$json.document_id}}"
        }
      },
      "id": "629",
      "name": "Salesforce - Attach Document",
      "type": "n8n-nodes-base.salesforce",
      "typeVersion": 1,
      "position": [3050, 450],
      "notes": "Attach document to Salesforce contact record",
      "credentials": {
        "salesforceOAuth2Api": {
          "id": "{{$env.SALESFORCE_CREDENTIAL_ID}}",
          "name": "Salesforce OAuth2"
        }
      },
      "continueOnFail": true
    },
    {
      "parameters": {
        "conditions": {
          "string": [
            {
              "value1": "={{$env.LOG_TARGET || 'sheets'}}",
              "value2": "sheets"
            }
          ]
        }
      },
      "id": "630",
      "name": "Switch: Google Sheets Logging",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [3450, 300],
      "notes": "Route to Google Sheets if LOG_TARGET=sheets"
    },
    {
      "parameters": {
        "authentication": "serviceAccount",
        "operation": "append",
        "documentId": "={{$env.GOOGLE_SHEET_ID}}",
        "sheetName": "={{$env.GOOGLE_SHEET_TAB || 'OCR_Log'}}",
        "columns": {
          "mappings": [
            {
              "column": "Timestamp",
              "value": "={{$json.capture_ts}}"
            },
            {
              "column": "Document ID",
              "value": "={{$json.document_id}}"
            },
            {
              "column": "Doc Type",
              "value": "={{$json.doc_type}}"
            },
            {
              "column": "Patient ID",
              "value": "={{$json.patient.external_id || 'N/A'}}"
            },
            {
              "column": "Patient Name",
              "value": "={{$json.patient.name || 'Unknown'}}"
            },
            {
              "column": "Source",
              "value": "={{$json.source}}"
            },
            {
              "column": "File Size (MB)",
              "value": "={{$json.file.size_mb}}"
            },
            {
              "column": "OCR Engine",
              "value": "={{$json.ocr_result.engine}}"
            },
            {
              "column": "Confidence",
              "value": "={{$json.ocr_result.confidence}}"
            },
            {
              "column": "Redacted",
              "value": "={{$json.ocr_result.redaction_applied || false}}"
            },
            {
              "column": "Storage URL",
              "value": "={{$json.storage.original_url}}"
            },
            {
              "column": "EHR Synced",
              "value": "={{$json.ehr_sync?.status || 'N/A'}}"
            },
            {
              "column": "CRM Synced",
              "value": "={{$json.crm_sync?.status || 'N/A'}}"
            },
            {
              "column": "Trace ID",
              "value": "={{$json.trace_id}}"
            }
          ]
        },
        "options": {}
      },
      "id": "631",
      "name": "Log to Google Sheets",
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4,
      "position": [3650, 250],
      "notes": "Append compliance log entry to Google Sheets",
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "{{$env.GOOGLE_SHEETS_CREDENTIAL_ID}}",
          "name": "Google Sheets OAuth2"
        }
      },
      "continueOnFail": true
    },
    {
      "parameters": {
        "authentication": "apiKey",
        "operation": "append",
        "baseId": "={{$env.AIRTABLE_BASE_ID}}",
        "table": "={{$env.AIRTABLE_TABLE || 'OCR_Log'}}",
        "columns": {
          "mappings": [
            {
              "column": "Timestamp",
              "value": "={{$json.capture_ts}}"
            },
            {
              "column": "Document ID",
              "value": "={{$json.document_id}}"
            },
            {
              "column": "Doc Type",
              "value": "={{$json.doc_type}}"
            },
            {
              "column": "Patient ID",
              "value": "={{$json.patient.external_id}}"
            },
            {
              "column": "OCR Engine",
              "value": "={{$json.ocr_result.engine}}"
            },
            {
              "column": "Confidence",
              "value": "={{$json.ocr_result.confidence}}"
            },
            {
              "column": "Storage URL",
              "value": "={{$json.storage.original_url}}"
            },
            {
              "column": "Trace ID",
              "value": "={{$json.trace_id}}"
            }
          ]
        },
        "options": {}
      },
      "id": "632",
      "name": "Log to Airtable",
      "type": "n8n-nodes-base.airtable",
      "typeVersion": 2,
      "position": [3650, 350],
      "notes": "Append compliance log entry to Airtable",
      "credentials": {
        "airtableTokenApi": {
          "id": "{{$env.AIRTABLE_CREDENTIAL_ID}}",
          "name": "Airtable API"
        }
      },
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// Build final structured_record.json response\nconst result = {\n  success: true,\n  document_id: $json.document_id,\n  doc_type: $json.doc_type,\n  patient: {\n    name: $json.patient.name,\n    email: $json.patient.email,\n    external_id: $json.patient.external_id\n  },\n  extracted: $json.extracted,\n  storage: {\n    original_url: $json.storage.original_url,\n    redacted_url: $json.storage.redacted_url || null\n  },\n  sync: {\n    ehr: $json.ehr_sync || { target: $env.EHR_TARGET, status: 'disabled' },\n    crm: $json.crm_sync || { target: $env.CRM_TARGET, status: 'disabled' }\n  },\n  metadata: {\n    ocr_engine: $json.ocr_result.engine,\n    confidence: $json.ocr_result.confidence,\n    processed_at: new Date().toISOString(),\n    logged_to_compliance: true\n  },\n  trace_id: $json.trace_id\n};\n\nreturn { json: result };"
      },
      "id": "633",
      "name": "Build structured_record.json",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [3850, 300],
      "notes": "Construct final standardized output schema"
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{JSON.stringify($json, null, 2)}}",
        "options": {
          "responseCode": 200
        }
      },
      "id": "634",
      "name": "Return Success Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [4050, 300],
      "notes": "Return structured_record.json to caller"
    },
    {
      "parameters": {
        "jsCode": "// Capture error details\nconst error = $input.item.json.error || 'Unknown error';\nconst stage = $input.item.json.stage || 'unknown';\nconst traceId = $input.item.json.trace_id || `ERR-${Date.now()}`;\n\nconst errorResponse = {\n  success: false,\n  error: error.message || error,\n  stage: stage,\n  trace_id: traceId,\n  timestamp: new Date().toISOString()\n};\n\n// Log to console if DEBUG_MODE\nif ($env.DEBUG_MODE === 'true') {\n  console.error('Module 06 Error:', JSON.stringify(errorResponse, null, 2));\n}\n\nreturn { json: errorResponse };"
      },
      "id": "635",
      "name": "Error Handler",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2050, 500],
      "notes": "Catch errors, log, and format error response"
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{JSON.stringify($json, null, 2)}}",
        "options": {
          "responseCode": 500
        }
      },
      "id": "636",
      "name": "Return Error Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [2250, 500],
      "notes": "Return error JSON with 500 status"
    }
  ],
  "connections": {
    "Webhook - Document Upload": {
      "main": [
        [
          {
            "node": "Identify Document & Extract Metadata",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Identify Document & Extract Metadata": {
      "main": [
        [
          {
            "node": "Validate Source, Size & MIME Type",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate Source, Size & MIME Type": {
      "main": [
        [
          {
            "node": "Select OCR Engine",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Return Validation Error",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Select OCR Engine": {
      "main": [
        [
          {
            "node": "Switch: Mistral OCR",
            "type": "main",
            "index": 0
          },
          {
            "node": "Switch: Gemini Vision",
            "type": "main",
            "index": 0
          },
          {
            "node": "Switch: ABBYY Cloud",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Switch: Mistral OCR": {
      "main": [
        [
          {
            "node": "Mistral OCR API",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Tesseract OCR (Self-Hosted)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Switch: Gemini Vision": {
      "main": [
        [
          {
            "node": "Google Gemini Vision API",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Switch: ABBYY Cloud": {
      "main": [
        [
          {
            "node": "ABBYY Cloud OCR API",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Mistral OCR API": {
      "main": [
        [
          {
            "node": "Post-Process OCR Output",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Google Gemini Vision API": {
      "main": [
        [
          {
            "node": "Post-Process OCR Output",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ABBYY Cloud OCR API": {
      "main": [
        [
          {
            "node": "Post-Process OCR Output",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Tesseract OCR (Self-Hosted)": {
      "main": [
        [
          {
            "node": "Post-Process OCR Output",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Post-Process OCR Output": {
      "main": [
        [
          {
            "node": "Map to Normalized Schema",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Map to Normalized Schema": {
      "main": [
        [
          {
            "node": "Check If Redaction Enabled",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check If Redaction Enabled": {
      "main": [
        [
          {
            "node": "Redact Sensitive Data",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Prepare Storage Paths",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Redact Sensitive Data": {
      "main": [
        [
          {
            "node": "Prepare Storage Paths",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Storage Paths": {
      "main": [
        [
          {
            "node": "Switch: S3 Storage",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Switch: S3 Storage": {
      "main": [
        [
          {
            "node": "Upload Original to S3",
            "type": "main",
            "index": 0
          },
          {
            "node": "Upload Redacted to S3 (If Enabled)",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Upload to Google Drive",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Upload Original to S3": {
      "main": [
        [
          {
            "node": "Generate Signed URLs",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Upload Redacted to S3 (If Enabled)": {
      "main": [
        [
          {
            "node": "Generate Signed URLs",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Signed URLs": {
      "main": [
        [
          {
            "node": "Check If EHR Sync Enabled",
            "type": "main",
            "index": 0
          },
          {
            "node": "Check If CRM Sync Enabled",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Upload to Google Drive": {
      "main": [
        [
          {
            "node": "Check If EHR Sync Enabled",
            "type": "main",
            "index": 0
          },
          {
            "node": "Check If CRM Sync Enabled",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check If EHR Sync Enabled": {
      "main": [
        [
          {
            "node": "Switch: DrChrono EHR",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Switch: Google Sheets Logging",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Switch: DrChrono EHR": {
      "main": [
        [
          {
            "node": "DrChrono - Attach Document",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Redox - Send Media Event",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "DrChrono - Attach Document": {
      "main": [
        [
          {
            "node": "Switch: Google Sheets Logging",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Redox - Send Media Event": {
      "main": [
        [
          {
            "node": "Switch: Google Sheets Logging",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check If CRM Sync Enabled": {
      "main": [
        [
          {
            "node": "HubSpot - Update Contact",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HubSpot - Update Contact": {
      "main": [
        [
          {
            "node": "Switch: Google Sheets Logging",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Salesforce - Attach Document": {
      "main": [
        [
          {
            "node": "Switch: Google Sheets Logging",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Switch: Google Sheets Logging": {
      "main": [
        [
          {
            "node": "Log to Google Sheets",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Log to Airtable",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Log to Google Sheets": {
      "main": [
        [
          {
            "node": "Build structured_record.json",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Log to Airtable": {
      "main": [
        [
          {
            "node": "Build structured_record.json",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build structured_record.json": {
      "main": [
        [
          {
            "node": "Return Success Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Error Handler": {
      "main": [
        [
          {
            "node": "Return Error Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "settings": {
    "executionOrder": "v1",
    "errorWorkflow": "{{$env.ERROR_WORKFLOW_ID}}"
  },
  "staticData": null,
  "tags": [],
  "triggerCount": 1,
  "updatedAt": "2025-01-15T00:00:00.000Z",
  "versionId": "1.0.0"
}
