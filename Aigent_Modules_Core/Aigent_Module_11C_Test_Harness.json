{
  "name": "Aigent_Module_11C_Test_Harness",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "connector-test",
        "responseMode": "responseNode",
        "options": {
          "allowedOrigins": "={{$env.ALLOWED_ORIGINS || 'http://localhost'}}"
        }
      },
      "id": "webhook",
      "name": "Webhook Trigger",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1.1,
      "position": [200, 300],
      "notes": "M11C: Automated connector testing"
    },
    {
      "parameters": {
        "jsCode": "// Add metadata\nconst body = $input.item.json.body || {};\nconst trace_id = `TEST-${Date.now()}-${Math.random().toString(36).substr(2, 6)}`;\nreturn {\n  test_mode: body.test_mode || 'all',\n  connector_id: body.connector_id || null,\n  trace_id,\n  timestamp: new Date().toISOString(),\n  start_time: Date.now()\n};"
      },
      "id": "metadata",
      "name": "Add Metadata",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [400, 300]
    },
    {
      "parameters": {
        "jsCode": "// Load registry file\nconst fs = require('fs');\nconst registryPath = process.env.CONNECTOR_REGISTRY_PATH || '/data/Aigent_Modules_Core/connectors_registry.json';\nconst registry = JSON.parse(fs.readFileSync(registryPath, 'utf8'));\n\nconst testMode = $input.item.json.test_mode;\nconst targetId = $input.item.json.connector_id;\nlet testTargets = [];\n\nif (testMode === 'single' && targetId) {\n  const connector = registry.find(c => c.id === targetId);\n  if (connector) testTargets = [connector];\n} else {\n  const underTest = process.env.CONNECTOR_UNDER_TEST;\n  if (underTest) {\n    const connector = registry.find(c => c.id === underTest);\n    if (connector) testTargets = [connector];\n  } else {\n    testTargets = registry;\n  }\n}\nreturn {\n  test_targets: testTargets,\n  total_connectors: testTargets.length,\n  trace_id: $input.item.json.trace_id,\n  start_time: $input.item.json.start_time\n};"
      },
      "id": "load-targets",
      "name": "Load Test Targets",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [600, 300]
    },
    {
      "parameters": {
        "jsCode": "// Split connectors into separate test items\nconst testTargets = $input.item.json.test_targets;\nconst trace_id = $input.item.json.trace_id;\nconst start_time = $input.item.json.start_time;\nreturn testTargets.map(connector => ({ connector, trace_id, start_time }));"
      },
      "id": "split-targets",
      "name": "Split Targets",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [800, 300]
    },
    {
      "parameters": {
        "jsCode": "// Test each connector across endpoints using helpers.httpRequest\nconst connector = $input.item.json.connector;\nconst endpoints = Object.keys(connector.endpoints || {});\nconst testResults = [];\n\nfor (const endpoint of endpoints) {\n  const testStart = Date.now();\n\n  // --- Mock test ---\n  let mockResult = {};\n  try {\n    const mockResponse = await this.helpers.httpRequest({\n      method: 'POST',\n      uri: `${process.env.N8N_BASE_URL}/webhook/connector-mock/mock-fetch`,\n      body: { connector_id: connector.id, endpoint },\n      json: true,\n      timeout: 5000\n    });\n    mockResult = { success: mockResponse.success !== false, duration_ms: Date.now() - testStart, source: 'mock' };\n  } catch (err) {\n    mockResult = { success: false, error: err.message, source: 'mock', duration_ms: Date.now() - testStart };\n  }\n\n  // --- Live test ---\n  let liveResult = null;\n  const mockModeGlobal = (process.env.MOCK_MODE_GLOBAL || 'false').toLowerCase() === 'true';\n  if (!mockModeGlobal) {\n    const liveStart = Date.now();\n    try {\n      const liveResponse = await this.helpers.httpRequest({\n        method: 'POST',\n        uri: `${process.env.N8N_BASE_URL}/webhook/connector/execute`,\n        body: { connector_id: connector.id, endpoint, payload: {} },\n        json: true,\n        timeout: parseInt(process.env.DEFAULT_TIMEOUT_MS || '10000')\n      });\n      liveResult = { success: liveResponse.success !== false, duration_ms: Date.now() - liveStart, source: 'live' };\n    } catch (err) {\n      liveResult = { success: false, error: err.message, source: 'live', duration_ms: Date.now() - liveStart };\n    }\n  }\n\n  testResults.push({ endpoint, mock: mockResult, live: liveResult, schema_check: 'skipped' });\n}\n\nconst totalTests = testResults.length * 2;\nconst passedTests = testResults.reduce((s, r) => s + (r.mock.success ? 1 : 0) + (r.live?.success ? 1 : 0), 0);\n\nreturn {\n  connector_id: connector.id,\n  connector_name: connector.name,\n  endpoints_tested: endpoints.length,\n  test_results: testResults,\n  tests_passed: passedTests,\n  tests_failed: totalTests - passedTests,\n  trace_id: $input.item.json.trace_id\n};"
      },
      "id": "test-connector",
      "name": "Test Connector",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1000, 300]
    },
    {
      "parameters": {
        "jsCode": "// Aggregate results with latency metrics\nconst allResults = $input.all().map(i => i.json);\nconst firstItem = $input.first().json;\n\nconst totalConnectors = allResults.length;\nconst totalTests = allResults.reduce((sum, r) => sum + r.tests_passed + r.tests_failed, 0);\nconst totalPassed = allResults.reduce((sum, r) => sum + r.tests_passed, 0);\nconst totalFailed = allResults.reduce((sum, r) => sum + r.tests_failed, 0);\n\n// --- Latency metrics ---\nlet totalLatency = 0;\nlet totalEndpoints = 0;\nfor (const r of allResults) {\n  for (const t of r.test_results) {\n    if (t.mock?.duration_ms) {\n      totalLatency += t.mock.duration_ms;\n      totalEndpoints++;\n    }\n    if (t.live?.duration_ms) {\n      totalLatency += t.live.duration_ms;\n      totalEndpoints++;\n    }\n  }\n}\nconst avgLatency = totalEndpoints > 0 ? Math.round(totalLatency / totalEndpoints) : 0;\nconst duration = Date.now() - (firstItem.start_time || Date.now());\n\nconst summary = {\n  success: totalFailed === 0,\n  trace_id: firstItem.trace_id || 'unknown',\n  timestamp: new Date().toISOString(),\n  duration_ms: duration,\n  average_latency_ms: avgLatency,\n  total_connectors: totalConnectors,\n  total_tests: totalTests,\n  tests_passed: totalPassed,\n  tests_failed: totalFailed,\n  success_rate: ((totalPassed / totalTests) * 100).toFixed(1),\n  detailed_results: allResults\n};\n\nreturn summary;"
      },
      "id": "aggregate-results",
      "name": "Aggregate Results",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1200, 300]
    },
    {
      "parameters": {
        "jsCode": "// Cache results to filesystem\nconst fs = require('fs');\nconst path = require('path');\nconst results = $input.item.json;\nconst cachePath = process.env.CACHE_PATH || '/data/Aigent_Modules_Core/cache';\n\nif (!fs.existsSync(cachePath)) fs.mkdirSync(cachePath, { recursive: true });\n\nconst cacheFile = path.join(cachePath, 'last_test_results.json');\nfs.writeFileSync(cacheFile, JSON.stringify(results, null, 2), 'utf8');\n\nconst timestamp = new Date().toISOString().replace(/[:.]/g, '-');\nconst historyFile = path.join(cachePath, `test_results_${timestamp}.json`);\nfs.writeFileSync(historyFile, JSON.stringify(results, null, 2), 'utf8');\n\nreturn { ...results, cache_status: 'written', cache_file: cacheFile, history_file: historyFile };"
      },
      "id": "cache-results",
      "name": "Cache Results",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1400, 300]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": { "responseCode": 200 }
      },
      "id": "return-success",
      "name": "Return Success",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [1600, 300]
    }
  ],
  "connections": {
    "Webhook Trigger": { "main": [[{ "node": "Add Metadata" }]] },
    "Add Metadata": { "main": [[{ "node": "Load Test Targets" }]] },
    "Load Test Targets": { "main": [[{ "node": "Split Targets" }]] },
    "Split Targets": { "main": [[{ "node": "Test Connector" }]] },
    "Test Connector": { "main": [[{ "node": "Aggregate Results" }]] },
    "Aggregate Results": { "main": [[{ "node": "Cache Results" }]] },
    "Cache Results": { "main": [[{ "node": "Return Success" }]] }
  },
  "active": true,
  "settings": { "executionOrder": "v1" }
}
