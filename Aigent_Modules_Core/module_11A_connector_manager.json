{
  "name": "Aigent_Module_11A_Connector_Manager",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "connector/:operation",
        "responseMode": "responseNode",
        "options": {
          "allowedOrigins": "={{$env.ALLOWED_ORIGINS || 'https://yourdomain.com'}}"
        }
      },
      "id": "webhook",
      "name": "Webhook Trigger",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1.1,
      "position": [200, 300],
      "notes": "M11A: Dynamic connector operations via path parameter\nOperations: lookup, normalize, execute, connector-resolve"
    },
    {
      "parameters": {
        "jsCode": "// M11A: Add metadata and extract operation\nconst operation = $input.item.json.params?.operation || 'execute';\nconst body = $input.item.json.body || {};\nconst trace_id = `CONN-${Date.now()}-${Math.random().toString(36).substr(2, 6)}`;\n\nreturn {\n  operation: operation,\n  body: body,\n  trace_id: trace_id,\n  timestamp: new Date().toISOString(),\n  start_time: Date.now()\n};"
      },
      "id": "metadata",
      "name": "Add Metadata",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [400, 300]
    },
    {
      "parameters": {
        "jsCode": "// M11A: Load and parse connectors registry (HARDENED)\nconst fs = require('fs');\nconst path = require('path');\n\n// Determine registry path - use absolute path instead of __dirname\nconst registryPath = process.env.CONNECTOR_REGISTRY_PATH || \n  '/data/Aigent_Modules_Core/connectors_registry.json';\n\ntry {\n  if (!fs.existsSync(registryPath)) {\n    return {\n      success: false,\n      error: 'Registry file not found',\n      registry_path: registryPath,\n      trace_id: $input.item.json.trace_id\n    };\n  }\n  \n  const registryData = fs.readFileSync(registryPath, 'utf8');\n  const connectors = JSON.parse(registryData);\n  \n  // Validate that connectors is an array\n  if (!Array.isArray(connectors)) {\n    return {\n      success: false,\n      error: 'Registry data is not an array',\n      registry_path: registryPath,\n      trace_id: $input.item.json.trace_id\n    };\n  }\n  \n  return {\n    success: true,\n    connectors: connectors,\n    registry_path: registryPath,\n    connector_count: connectors.length,\n    trace_id: $input.item.json.trace_id\n  };\n} catch (error) {\n  return {\n    success: false,\n    error: 'Failed to load registry',\n    error_message: error.message,\n    registry_path: registryPath,\n    trace_id: $input.item.json.trace_id\n  };\n}"
      },
      "id": "load-registry",
      "name": "Load Registry",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [600, 300],
      "notes": "M11A: Load connectors_registry.json - HARDENED with validations"
    },
    {
      "parameters": {
        "mode": "expression",
        "output": "={{ $json.success === true ? 'success' : 'error' }}"
      },
      "id": "check-registry",
      "name": "Check Registry Loaded",
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3,
      "position": [800, 300],
      "notes": "M11A: Route based on registry load success (SWITCH node for import stability)"
    },
    {
      "parameters": {
        "mode": "expression",
        "output": "={{ $('Add Metadata').first().json.operation }}"
      },
      "id": "route-operation",
      "name": "Route Operation",
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3,
      "position": [1000, 240],
      "notes": "M11A: Route to operation handler (SWITCH for stability)\nOutputs: lookup, normalize, execute, connector-resolve"
    },
    {
      "parameters": {
        "jsCode": "// M11A: Lookup connector by ID (HARDENED)\nconst registryData = $('Load Registry').first()?.json;\nconst metadata = $('Add Metadata').first()?.json;\n\nif (!registryData?.connectors) {\n  return {\n    success: false,\n    error: 'Registry data not available',\n    trace_id: metadata?.trace_id\n  };\n}\n\nconst connectors = registryData.connectors;\nconst requestedId = metadata?.body?.connector_id;\n\nif (!requestedId) {\n  return {\n    success: false,\n    error: 'connector_id is required',\n    trace_id: metadata?.trace_id\n  };\n}\n\n// Validate connectors is array before find\nif (!Array.isArray(connectors)) {\n  return {\n    success: false,\n    error: 'Invalid registry data structure',\n    trace_id: metadata?.trace_id\n  };\n}\n\nconst connector = connectors.find(c => c?.id === requestedId);\n\nif (!connector) {\n  return {\n    success: false,\n    error: 'Connector not found',\n    connector_id: requestedId,\n    available_connectors: connectors.map(c => c.id).filter(Boolean)\n  };\n}\n\nreturn {\n  success: true,\n  connector: connector,\n  trace_id: metadata?.trace_id\n};"
      },
      "id": "lookup-handler",
      "name": "Lookup Handler",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1200, 100],
      "notes": "M11A: Find connector definition by ID - HARDENED"
    },
    {
      "parameters": {
        "jsCode": "// M11A: Normalize request/response payloads (HARDENED)\nconst registryData = $('Load Registry').first()?.json;\nconst metadata = $('Add Metadata').first()?.json;\n\nif (!registryData?.connectors) {\n  return { success: false, error: 'Registry data not available' };\n}\n\nconst connectors = registryData.connectors;\nconst connectorId = metadata?.body?.connector_id;\nconst payload = metadata?.body?.payload;\nconst direction = metadata?.body?.direction || 'request';\n\nif (!connectorId) {\n  return { success: false, error: 'connector_id is required' };\n}\n\nif (!Array.isArray(connectors)) {\n  return { success: false, error: 'Invalid registry data' };\n}\n\nconst connector = connectors.find(c => c?.id === connectorId);\n\nif (!connector) {\n  return { success: false, error: 'Connector not found', connector_id: connectorId };\n}\n\nif (!connector.type) {\n  return { success: false, error: 'Connector has no type defined', connector_id: connectorId };\n}\n\n// Apply normalization adapters\nconst adapters = {\n  calendar: {\n    normalizeRequest: (req) => ({\n      date: req?.date || req?.preferred_date || new Date().toISOString().split('T')[0],\n      duration: req?.duration || 30,\n      timezone: req?.timezone || 'America/New_York'\n    }),\n    normalizeResponse: (res) => ({\n      slots: res?.slots || res?.data?.slots || res?.available_times || [],\n      next_available: res?.next_available || (res?.slots && res.slots[0]) || null\n    })\n  },\n  messaging: {\n    normalizeRequest: (req) => ({\n      recipient: req?.recipient || req?.to || req?.email,\n      message: req?.message || req?.body || req?.text,\n      channel: req?.channel || 'email'\n    }),\n    normalizeResponse: (res) => ({\n      message_id: res?.message_id || res?.id || res?.sid,\n      status: res?.status || 'sent'\n    })\n  },\n  video: {\n    normalizeRequest: (req) => ({\n      topic: req?.topic || 'Video Meeting',\n      start_time: req?.start_time || new Date().toISOString(),\n      duration: req?.duration || 60\n    }),\n    normalizeResponse: (res) => ({\n      meeting_id: res?.meeting_id || res?.id,\n      join_url: res?.join_url || res?.url,\n      start_url: res?.start_url || res?.host_url\n    })\n  },\n  payment: {\n    normalizeRequest: (req) => ({\n      amount: req?.amount,\n      currency: req?.currency || 'USD',\n      customer_email: req?.customer_email || req?.email\n    }),\n    normalizeResponse: (res) => ({\n      charge_id: res?.charge_id || res?.id,\n      status: res?.status,\n      receipt_url: res?.receipt_url\n    })\n  },\n  storage: {\n    normalizeRequest: (req) => req || {},\n    normalizeResponse: (res) => res || {}\n  },\n  crm: {\n    normalizeRequest: (req) => ({\n      fields: req?.fields || req?.data\n    }),\n    normalizeResponse: (res) => ({\n      record_id: res?.record_id || res?.id\n    })\n  }\n};\n\nconst adapter = adapters[connector.type] || { \n  normalizeRequest: (r) => r || {}, \n  normalizeResponse: (r) => r || {} \n};\n\nconst normalized = direction === 'request' \n  ? adapter.normalizeRequest(payload || {})\n  : adapter.normalizeResponse(payload || {});\n\nreturn {\n  success: true,\n  connector_id: connectorId,\n  connector_type: connector.type,\n  direction: direction,\n  original_payload: payload,\n  normalized_payload: normalized,\n  trace_id: metadata?.trace_id\n};"
      },
      "id": "normalize-handler",
      "name": "Normalize Handler",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1200, 220],
      "notes": "M11A: Apply type-specific normalization adapters - HARDENED"
    },
    {
      "parameters": {
        "jsCode": "// M11A: Execute connector call - Determine mode (HARDENED)\nconst mockModeGlobal = (process.env.MOCK_MODE_GLOBAL || 'false').toLowerCase() === 'true';\nconst registryData = $('Load Registry').first()?.json;\nconst metadata = $('Add Metadata').first()?.json;\n\nif (!registryData?.connectors) {\n  return { success: false, error: 'Registry data not available' };\n}\n\nconst connectors = registryData.connectors;\nconst connectorId = metadata?.body?.connector_id;\nconst endpoint = metadata?.body?.endpoint;\nconst payload = metadata?.body?.payload || {};\n\nif (!connectorId) {\n  return { success: false, error: 'connector_id is required' };\n}\n\nif (!endpoint) {\n  return { success: false, error: 'endpoint is required' };\n}\n\nif (!Array.isArray(connectors)) {\n  return { success: false, error: 'Invalid registry data' };\n}\n\nconst connector = connectors.find(c => c?.id === connectorId);\n\nif (!connector) {\n  return { \n    success: false, \n    error: 'Connector not found', \n    connector_id: connectorId \n  };\n}\n\nif (!connector.type) {\n  return { \n    success: false, \n    error: 'Connector type not defined', \n    connector_id: connectorId \n  };\n}\n\nif (!connector.endpoints || typeof connector.endpoints !== 'object') {\n  return { \n    success: false, \n    error: 'Connector has no endpoints defined', \n    connector_id: connectorId \n  };\n}\n\nif (!connector.endpoints[endpoint]) {\n  return { \n    success: false, \n    error: 'Endpoint not found', \n    endpoint: endpoint, \n    available_endpoints: Object.keys(connector.endpoints) \n  };\n}\n\nconst endpointDef = connector.endpoints[endpoint];\n\n// Check for connector-specific or global mock mode\nconst connectorMockMode = process.env[`MOCK_${connector.type.toUpperCase()}`];\nconst useMock = mockModeGlobal || (connectorMockMode && connectorMockMode.toLowerCase() === 'true');\n\nif (useMock) {\n  // Mock mode - delegate to M11B\n  return {\n    success: true,\n    mode: 'mock',\n    connector_id: connectorId,\n    endpoint: endpoint,\n    mock_file: connector.mock?.file,\n    delegate_to: 'module_11B',\n    payload: payload,\n    trace_id: metadata?.trace_id\n  };\n}\n\n// Live mode - prepare HTTP request\nif (!connector.base_url) {\n  return { \n    success: false, \n    error: 'Connector base_url not defined', \n    connector_id: connectorId \n  };\n}\n\n// Replace env vars in base_url\nconst baseUrl = connector.base_url.replace(/{{\\$env\\.(\\w+)}}/g, (match, envVar) => {\n  return process.env[envVar] || match;\n});\n\nif (!endpointDef.path) {\n  return { \n    success: false, \n    error: 'Endpoint path not defined', \n    endpoint: endpoint \n  };\n}\n\n// Proper URL joining - avoid double slashes\nlet url = baseUrl;\nif (!url.endsWith('/') && !endpointDef.path.startsWith('/')) {\n  url += '/';\n} else if (url.endsWith('/') && endpointDef.path.startsWith('/')) {\n  url = url.slice(0, -1);\n}\nurl += endpointDef.path;\n\nconst method = endpointDef.method || 'POST';\n\n// Map payload to request format\nconst mappedPayload = {};\nconst requestMap = endpointDef.request_map || {};\nfor (const [key, value] of Object.entries(requestMap)) {\n  mappedPayload[key] = payload[value] || payload[key];\n}\n\nreturn {\n  success: true,\n  mode: 'live',\n  connector_id: connectorId,\n  connector_type: connector.type,\n  endpoint: endpoint,\n  url: url,\n  method: method,\n  payload: Object.keys(mappedPayload).length > 0 ? mappedPayload : payload,\n  auth: connector.auth || {},\n  response_map: endpointDef.response_map || {},\n  trace_id: metadata?.trace_id\n};"
      },
      "id": "execute-handler",
      "name": "Execute Handler",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1200, 340],
      "notes": "M11A: Determine mode (live/mock) and prepare request - HARDENED"
    },
    {
      "parameters": {
        "mode": "expression",
        "output": "={{ $json.mode }}"
      },
      "id": "check-mode",
      "name": "Check Mode",
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3,
      "position": [1400, 340],
      "notes": "M11A: Route based on execution mode (SWITCH for stability)"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{$env.N8N_BASE_URL}}/webhook/connector/mock-fetch",
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "connector_id",
              "value": "={{ $json.connector_id }}"
            },
            {
              "name": "endpoint",
              "value": "={{ $json.endpoint }}"
            },
            {
              "name": "mock_file",
              "value": "={{ $json.mock_file }}"
            }
          ]
        },
        "options": {
          "timeout": "={{$env.DEFAULT_TIMEOUT_MS || 10000}}"
        }
      },
      "id": "call-mock",
      "name": "Call Mock Simulator",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1600, 280],
      "notes": "M11A: Delegate to M11B for mock response - FIXED timeout"
    },
    {
      "parameters": {
        "jsCode": "// M11A: Execute live HTTP request using helpers.httpRequest (HARDENED)\nconst execData = $input.item.json;\n\nif (!execData.url) {\n  return {\n    success: false,\n    error: 'No URL provided',\n    trace_id: execData.trace_id\n  };\n}\n\nconst headers = {\n  'Content-Type': 'application/json',\n  'User-Agent': 'Aigent-ConnectorManager/1.0'\n};\n\n// Apply authentication\nif (execData.auth?.mode === 'bearer') {\n  const tokenEnv = execData.auth.token_env;\n  if (tokenEnv) {\n    const token = process.env[tokenEnv];\n    if (token) {\n      headers['Authorization'] = `Bearer ${token}`;\n    } else {\n      return {\n        success: false,\n        error: `Auth token not found in env: ${tokenEnv}`,\n        connector_id: execData.connector_id,\n        trace_id: execData.trace_id\n      };\n    }\n  }\n} else if (execData.auth?.mode === 'apiKey') {\n  const keyEnv = execData.auth.key_env;\n  if (keyEnv) {\n    const key = process.env[keyEnv];\n    if (key) {\n      headers['Authorization'] = `Bearer ${key}`;\n    } else {\n      return {\n        success: false,\n        error: `API key not found in env: ${keyEnv}`,\n        connector_id: execData.connector_id,\n        trace_id: execData.trace_id\n      };\n    }\n  }\n}\n\nconst timeout = parseInt(process.env.DEFAULT_TIMEOUT_MS || '10000');\n\ntry {\n  const startTime = Date.now();\n  \n  // Use helpers.httpRequest instead of axios for n8n compatibility\n  const response = await this.helpers.httpRequest({\n    method: execData.method || 'POST',\n    url: execData.url,\n    body: execData.payload,\n    headers: headers,\n    json: true,\n    timeout: timeout\n  });\n  \n  const duration = Date.now() - startTime;\n  \n  // Map response fields\n  const mappedResponse = {};\n  const responseMap = execData.response_map || {};\n  for (const [key, value] of Object.entries(responseMap)) {\n    const keys = value.split('.');\n    let val = response;\n    for (const k of keys) {\n      val = val?.[k];\n    }\n    mappedResponse[key] = val;\n  }\n  \n  return {\n    success: true,\n    source: 'live',\n    connector_id: execData.connector_id,\n    endpoint: execData.endpoint,\n    data: Object.keys(mappedResponse).length > 0 ? mappedResponse : response,\n    raw_response: response,\n    duration_ms: duration,\n    trace_id: execData.trace_id\n  };\n} catch (error) {\n  return {\n    success: false,\n    source: 'live',\n    error: error.message || 'HTTP request failed',\n    error_details: error.response?.data || error.response?.statusText,\n    status_code: error.response?.status,\n    connector_id: execData.connector_id,\n    endpoint: execData.endpoint,\n    trace_id: execData.trace_id\n  };\n}"
      },
      "id": "execute-live",
      "name": "Execute Live Request",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1600, 400],
      "notes": "M11A: Execute live HTTP request - HARDENED with helpers.httpRequest"
    },
    {
      "parameters": {
        "jsCode": "// M11A: Resolve connector details for dependent modules (HARDENED)\nconst registryData = $('Load Registry').first()?.json;\nconst metadata = $('Add Metadata').first()?.json;\n\nif (!registryData?.connectors) {\n  return { success: false, error: 'Registry data not available' };\n}\n\nconst connectors = registryData.connectors;\nconst moduleId = metadata?.body?.module_id;\nconst serviceType = metadata?.body?.service_type;\n\nif (!moduleId && !serviceType) {\n  return {\n    success: false,\n    error: 'Either module_id or service_type is required'\n  };\n}\n\nif (!Array.isArray(connectors)) {\n  return { success: false, error: 'Invalid registry data' };\n}\n\n// Find connectors used by this module\nconst moduleConnectors = connectors.filter(c => {\n  if (!c) return false;\n  \n  const matchesModule = moduleId && \n    Array.isArray(c.modules_using) && \n    c.modules_using.includes(moduleId);\n  \n  const matchesType = serviceType && c.type === serviceType;\n  \n  return matchesModule || matchesType;\n});\n\nif (moduleConnectors.length === 0) {\n  return {\n    success: false,\n    error: 'No connectors found',\n    module_id: moduleId,\n    service_type: serviceType,\n    total_connectors: connectors.length\n  };\n}\n\n// Return primary connector (first match)\nconst primary = moduleConnectors[0];\n\nreturn {\n  success: true,\n  module_id: moduleId,\n  service_type: serviceType,\n  primary_connector: {\n    id: primary.id,\n    name: primary.name,\n    type: primary.type,\n    base_url: primary.base_url,\n    endpoints: primary.endpoints ? Object.keys(primary.endpoints) : []\n  },\n  alternatives: moduleConnectors.slice(1).map(c => ({\n    id: c?.id,\n    name: c?.name\n  })).filter(c => c.id),\n  trace_id: metadata?.trace_id\n};"
      },
      "id": "resolve-handler",
      "name": "Resolve Handler",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1200, 460],
      "notes": "M11A: Resolve connector config for calling module - HARDENED"
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {
          "responseCode": 200
        }
      },
      "id": "return-success",
      "name": "Return Success",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [1800, 340]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ {success: false, error: 'Registry load failed', details: $('Load Registry').first().json} }}",
        "options": {
          "responseCode": 500
        }
      },
      "id": "return-registry-error",
      "name": "Return Registry Error",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [1000, 420]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ {success: false, error: 'Invalid operation', operation: $('Add Metadata').first().json.operation, valid_operations: ['lookup', 'normalize', 'execute', 'connector-resolve']} }}",
        "options": {
          "responseCode": 400
        }
      },
      "id": "return-invalid-op",
      "name": "Return Invalid Operation",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [1400, 560]
    }
  ],
  "connections": {
    "Webhook Trigger": {
      "main": [[{"node": "Add Metadata"}]]
    },
    "Add Metadata": {
      "main": [[{"node": "Load Registry"}]]
    },
    "Load Registry": {
      "main": [[{"node": "Check Registry Loaded"}]]
    },
    "Check Registry Loaded": {
      "main": [
        [{"node": "Route Operation"}],
        [{"node": "Return Registry Error"}]
      ]
    },
    "Route Operation": {
      "main": [
        [{"node": "Lookup Handler"}],
        [{"node": "Normalize Handler"}],
        [{"node": "Execute Handler"}],
        [{"node": "Resolve Handler"}],
        [{"node": "Return Invalid Operation"}]
      ]
    },
    "Lookup Handler": {
      "main": [[{"node": "Return Success"}]]
    },
    "Normalize Handler": {
      "main": [[{"node": "Return Success"}]]
    },
    "Execute Handler": {
      "main": [[{"node": "Check Mode"}]]
    },
    "Check Mode": {
      "main": [
        [{"node": "Call Mock Simulator"}],
        [{"node": "Execute Live Request"}]
      ]
    },
    "Call Mock Simulator": {
      "main": [[{"node": "Return Success"}]]
    },
    "Execute Live Request": {
      "main": [[{"node": "Return Success"}]]
    },
    "Resolve Handler": {
      "main": [[{"node": "Return Success"}]]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "tags": [
    {
      "id": "aigent-core",
      "name": "Aigent-Core"
    },
    {
      "id": "module-11",
      "name": "Module-11"
    },
    {
      "id": "connector-manager",
      "name": "Connector-Manager"
    },
    {
      "id": "hardened-v2",
      "name": "Hardened-v2"
    }
  ],
  "meta": {
    "version": "2.0.0",
    "branch": "Core",
    "description": "Module 11A: Universal Connector Manager - HARDENED for n8n v1.118.2 import stability",
    "operations": [
      "lookup - Find connector definition by ID",
      "normalize - Standardize request/response payloads",
      "execute - Run live or mock connector call",
      "connector-resolve - Get connector config for calling module"
    ],
    "required_vars": [
      "N8N_BASE_URL (required for mock delegation)"
    ],
    "recommended_vars": [
      "CONNECTOR_REGISTRY_PATH (default: /data/Aigent_Modules_Core/connectors_registry.json)"
    ],
    "optional_vars": [
      "MOCK_MODE_GLOBAL (true/false)",
      "MOCK_CALENDAR (true/false)",
      "MOCK_MESSAGING (true/false)",
      "MOCK_PAYMENTS (true/false)",
      "MOCK_VIDEO (true/false)",
      "DEFAULT_TIMEOUT_MS (default: 10000)",
      "ALLOWED_ORIGINS (CORS configuration)"
    ],
    "features": [
      "Registry-driven connector management",
      "Live and mock mode switching",
      "Type-specific normalization adapters",
      "Dynamic authentication handling",
      "Response field mapping",
      "Module-specific connector resolution"
    ],
    "hardening": [
      "✅ All IF nodes converted to Switch nodes (import-safe)",
      "✅ Removed __dirname usage - absolute paths",
      "✅ Comprehensive null/undefined guards",
      "✅ Array validation before operations",
      "✅ helpers.httpRequest instead of axios",
      "✅ Proper URL joining logic",
      "✅ Environment variable validation",
      "✅ Enhanced error messages"
    ]
  }
}
