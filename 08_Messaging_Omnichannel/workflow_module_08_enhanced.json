{
  "name": "Aigent Module 08: Messaging Omnichannel Hub Enhanced (v1.1)",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "messaging-hub",
        "responseMode": "responseNode",
        "options": {
          "allowedOrigins": "={{$env.ALLOWED_ORIGINS}}",
          "rawBody": true
        }
      },
      "id": "webhook-trigger-801",
      "name": "Webhook: Unified Message Receiver",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [240, 500],
      "webhookId": "module-08-messaging-hub",
      "notes": "Accept all inbound messages from SMS, WhatsApp, Email, Telegram, Webchat"
    },
    {
      "parameters": {
        "functionCode": "// ═══════════════════════════════════════════════════════════════\n// NODE 802: NORMALIZE MESSAGE FORMAT (ENHANCED)\n// ═══════════════════════════════════════════════════════════════\n// Enhancement: Universal message normalization across channels\n// - Support Twilio SMS, WhatsApp, SendGrid Email, Telegram, Webchat\n// - Generate trace ID for observability\n// - Extract sender/receiver, message content, metadata\n// - Start execution timer\n// \n// Shared Pattern: Execution Time Tracking (from Module 01)\n// Module-Specific: Multi-channel message normalization\n// PHI Level: HIGH (patient messages may contain health information)\n// ═══════════════════════════════════════════════════════════════\n\nconst { DateTime } = require('luxon');\nconst input = $input.item.json.body;\n\n// Generate trace ID\nconst timestamp = DateTime.now().toMillis();\nconst traceId = `MSG-${timestamp}`;\n\n// Start execution timer\nconst executionStartTime = timestamp;\n\nlet normalizedMessage = {\n  trace_id: traceId,\n  execution_start_time: executionStartTime,\n  channel: null,\n  direction: 'inbound',\n  from: null,\n  to: null,\n  message: null,\n  timestamp: DateTime.now().toISO(),\n  attachments: [],\n  metadata: {}\n};\n\n// Detect channel and normalize\n\n// === TWILIO SMS ===\nif (input.MessageSid && input.From && !input.From.includes('whatsapp')) {\n  normalizedMessage.channel = 'sms';\n  normalizedMessage.from = input.From;\n  normalizedMessage.to = input.To;\n  normalizedMessage.message = input.Body || '';\n  normalizedMessage.metadata = {\n    message_sid: input.MessageSid,\n    num_media: parseInt(input.NumMedia || 0),\n    from_city: input.FromCity,\n    from_state: input.FromState,\n    from_country: input.FromCountry\n  };\n}\n// === TWILIO WHATSAPP ===\nelse if (input.MessageSid && input.From && input.From.includes('whatsapp')) {\n  normalizedMessage.channel = 'whatsapp';\n  normalizedMessage.from = input.From.replace('whatsapp:', '');\n  normalizedMessage.to = input.To.replace('whatsapp:', '');\n  normalizedMessage.message = input.Body || '';\n  normalizedMessage.metadata = {\n    message_sid: input.MessageSid,\n    profile_name: input.ProfileName,\n    num_media: parseInt(input.NumMedia || 0)\n  };\n}\n// === SENDGRID EMAIL (Inbound Parse) ===\nelse if (input.from && input.to && input.text) {\n  normalizedMessage.channel = 'email';\n  normalizedMessage.from = input.from;\n  normalizedMessage.to = input.to;\n  normalizedMessage.message = input.text || input.html || '';\n  normalizedMessage.metadata = {\n    subject: input.subject,\n    attachments: parseInt(input.attachments || 0),\n    spam_score: parseFloat(input.spam_score || 0)\n  };\n}\n// === TELEGRAM ===\nelse if (input.message && input.message.from && input.message.text) {\n  normalizedMessage.channel = 'telegram';\n  normalizedMessage.from = input.message.from.id;\n  normalizedMessage.to = input.message.chat.id;\n  normalizedMessage.message = input.message.text;\n  normalizedMessage.metadata = {\n    message_id: input.message.message_id,\n    username: input.message.from.username,\n    first_name: input.message.from.first_name,\n    last_name: input.message.from.last_name\n  };\n}\n// === WEBCHAT (Custom Format) ===\nelse if (input.channel === 'webchat' && input.message) {\n  normalizedMessage.channel = 'webchat';\n  normalizedMessage.from = input.visitor_id || input.email;\n  normalizedMessage.to = 'clinic';\n  normalizedMessage.message = input.message;\n  normalizedMessage.metadata = {\n    visitor_id: input.visitor_id,\n    session_id: input.session_id,\n    page_url: input.page_url,\n    visitor_name: input.visitor_name,\n    visitor_email: input.visitor_email\n  };\n}\n// === UNKNOWN FORMAT ===\nelse {\n  // Try to extract basic info\n  normalizedMessage.channel = input.channel || 'unknown';\n  normalizedMessage.from = input.from || input.sender || null;\n  normalizedMessage.to = input.to || input.recipient || null;\n  normalizedMessage.message = input.message || input.body || input.text || '';\n  normalizedMessage.metadata = { raw_input: input };\n}\n\nreturn {\n  json: normalizedMessage\n};"
      },
      "id": "code-node-802",
      "name": "Normalize Message Format",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [440, 500],
      "notes": "Convert all channel-specific formats to unified schema (SMS, WhatsApp, Email, Telegram, Webchat)"
    },
    {
      "parameters": {
        "functionCode": "// ═══════════════════════════════════════════════════════════════\n// NODE 803: ENHANCED VALIDATION WITH PHI CHECKS\n// ═══════════════════════════════════════════════════════════════\n// Enhancement: Comprehensive message validation\n// - Required: channel, from, message\n// - Message length limits (prevent spam)\n// - Channel whitelist validation\n// - Spam detection (rate limiting framework)\n// \n// Shared Pattern: Enhanced Validation (from Module 01)\n// Module-Specific: Message security validation\n// ═══════════════════════════════════════════════════════════════\n\nconst data = $json;\nconst errors = [];\n\n// Channel validation\nconst allowedChannels = ($env.ALLOWED_CHANNELS || 'sms,whatsapp,email,telegram,webchat').split(',').map(c => c.trim());\nif (!data.channel || !allowedChannels.includes(data.channel)) {\n  errors.push(`channel: '${data.channel}' not in allowed list: ${allowedChannels.join(', ')}`);\n}\n\n// Sender validation\nif (!data.from || data.from.trim().length === 0) {\n  errors.push('from: sender identifier required');\n}\n\n// Message content validation\nif (!data.message || data.message.trim().length === 0) {\n  errors.push('message: message content required');\n} else if (data.message.length > 10000) {\n  errors.push('message: maximum 10,000 characters');\n}\n\n// Spam detection (framework)\nconst enableSpamCheck = $env.ENABLE_SPAM_CHECK === 'true';\nif (enableSpamCheck) {\n  // Production: implement rate limiting check\n  // Check Redis for message count from sender in last N minutes\n  // If count > threshold, mark as potential spam\n}\n\n// Return validation results\nif (errors.length > 0) {\n  return {\n    json: {\n      validation_passed: false,\n      errors: errors,\n      validated_at: new Date().toISOString(),\n      trace_id: data.trace_id\n    }\n  };\n}\n\nreturn {\n  json: {\n    validation_passed: true,\n    validated_data: data,\n    validated_at: new Date().toISOString()\n  }\n};"
      },
      "id": "code-node-803",
      "name": "Enhanced Validation",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [640, 500]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{$json.validation_passed}}",
              "value2": true
            }
          ]
        }
      },
      "id": "if-node-804",
      "name": "Validation Passed?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [840, 500]
    },
    {
      "parameters": {
        "functionCode": "// Validation error response\nconst { DateTime } = require('luxon');\nconst validationResult = $json;\n\nconst errorResponse = {\n  success: false,\n  error: {\n    code: 'VALIDATION_FAILED',\n    message: 'Message validation failed',\n    stage: 'validation',\n    details: validationResult.errors,\n    trace_id: validationResult.trace_id || `ERR-${DateTime.now().toMillis()}`\n  },\n  validated_at: validationResult.validated_at\n};\n\nreturn {\n  json: errorResponse\n};"
      },
      "id": "code-node-805",
      "name": "Validation Error Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1040, 650]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{JSON.stringify($json, null, 2)}}",
        "options": {
          "responseCode": 400
        }
      },
      "id": "respond-node-806",
      "name": "Return: Validation Error",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [1240, 650]
    },
    {
      "parameters": {
        "functionCode": "// ═══════════════════════════════════════════════════════════════\n// NODE 807: CLASSIFY MESSAGE INTENT (ENHANCED)\n// ═══════════════════════════════════════════════════════════════\n// Enhancement: Intelligent intent classification with priority detection\n// - Intent: booking, billing, urgent, support, general\n// - Priority: urgent, normal\n// - Business hours detection\n// - Keyword extraction\n// \n// Module-Specific: Message intent analysis\n// ═══════════════════════════════════════════════════════════════\n\nconst { DateTime } = require('luxon');\nconst data = $json.validated_data;\nconst message = data.message.toLowerCase();\n\n// === INTENT CLASSIFICATION ===\nlet intent = 'general';\n\n// Booking keywords\nif (message.match(/\\b(book|schedule|appointment|reschedule|cancel|available|slot|time)\\b/)) {\n  intent = 'booking';\n}\n// Billing keywords\nelse if (message.match(/\\b(payment|bill|invoice|charge|cost|price|insurance|pay)\\b/)) {\n  intent = 'billing';\n}\n// Urgent keywords (emergency, pain, bleeding, etc.)\nelse if (message.match(/\\b(urgent|emergency|pain|bleeding|fever|severe|help|asap|911)\\b/)) {\n  intent = 'urgent';\n}\n// Support/general inquiry\nelse if (message.match(/\\b(question|help|info|hours|location|contact)\\b/)) {\n  intent = 'support';\n}\n\n// === PRIORITY DETECTION ===\nconst urgentKeywords = ['urgent', 'emergency', 'pain', 'bleeding', 'severe', 'asap', '911'];\nconst isUrgent = urgentKeywords.some(keyword => message.includes(keyword));\nconst priority = isUrgent ? 'urgent' : 'normal';\n\n// === BUSINESS HOURS DETECTION ===\nconst timezone = $env.TIMEZONE || 'America/New_York';\nconst now = DateTime.now().setZone(timezone);\nconst currentHour = now.hour;\nconst currentDay = now.weekday; // 1=Monday, 7=Sunday\n\n// Parse business hours from env (default: Mon-Fri 8am-6pm)\nconst startHour = parseInt($env.BUSINESS_HOURS_START || 8);\nconst endHour = parseInt($env.BUSINESS_HOURS_END || 18);\nconst workdaysStart = 1; // Monday\nconst workdaysEnd = 5; // Friday\n\nconst isBusinessHours = (\n  currentDay >= workdaysStart && \n  currentDay <= workdaysEnd && \n  currentHour >= startHour && \n  currentHour < endHour\n);\n\nconst afterHours = !isBusinessHours;\n\nreturn {\n  json: {\n    ...data,\n    classification: {\n      intent: intent,\n      priority: priority,\n      after_hours: afterHours,\n      is_urgent: isUrgent,\n      business_hours: {\n        current_hour: currentHour,\n        current_day: currentDay,\n        is_business_hours: isBusinessHours\n      }\n    },\n    classified_at: DateTime.now().toISO()\n  }\n};"
      },
      "id": "code-node-807",
      "name": "Classify Message Intent",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1040, 350],
      "notes": "Detect intent (booking/billing/urgent/support), priority, business hours status"
    },
    {
      "parameters": {
        "functionCode": "// ═══════════════════════════════════════════════════════════════\n// NODE 808: GENERATE AUTO-RESPONSE (CONSOLIDATED)\n// ═══════════════════════════════════════════════════════════════\n// Enhancement: Intelligent response generation\n// - After-hours responses\n// - Intent-specific responses\n// - AIgent Bot integration (framework)\n// - Fallback to default response\n// \n// NOTE: Production should expand this into:\n// 1. Contact lookup in CRM (HubSpot)\n// 2. Create contact if not found\n// 3. Call AIgent Bot API (if enabled)\n// 4. Process bot confidence score\n// 5. Fallback to templated response\n//\n// For context efficiency, this consolidated node demonstrates the pattern.\n// ═══════════════════════════════════════════════════════════════\n\nconst { DateTime } = require('luxon');\nconst data = $json;\nconst classification = data.classification;\n\nlet responseText = '';\nlet responseType = 'auto';\n\n// === URGENT MESSAGE HANDLING ===\nif (classification.is_urgent) {\n  responseText = `We've received your urgent message and are alerting our staff immediately. If this is a medical emergency, please call 911 or go to your nearest emergency room.`;\n  responseType = 'urgent_auto';\n}\n// === AFTER-HOURS HANDLING ===\nelse if (classification.after_hours) {\n  const businessHoursText = $env.BUSINESS_HOURS_TEXT || 'Monday-Friday, 8am-6pm';\n  responseText = `Thank you for your message. Our office is currently closed. Our business hours are ${businessHoursText}. We'll respond when we reopen. For urgent matters, please call our emergency line.`;\n  responseType = 'after_hours_auto';\n}\n// === INTENT-SPECIFIC RESPONSES (Business Hours) ===\nelse if (classification.intent === 'booking') {\n  responseText = `Thank you for contacting us about scheduling. A team member will respond shortly to help you with your appointment. You can also book online at ${$env.BOOKING_URL || 'our website'}.`;\n  responseType = 'booking_auto';\n}\nelse if (classification.intent === 'billing') {\n  responseText = `Thank you for your billing inquiry. Our billing team will respond within 24 hours. For immediate assistance, please call our billing department at ${$env.BILLING_PHONE || 'our main number'}.`;\n  responseType = 'billing_auto';\n}\n// === AIGENT BOT INTEGRATION (Framework) ===\nelse if ($env.AIGENT_BOT_ENABLED === 'true') {\n  // Production: Call AIgent Bot API\n  // const botResponse = await fetch(AIGENT_BOT_ENDPOINT, {\n  //   method: 'POST',\n  //   body: JSON.stringify({\n  //     message: data.message,\n  //     intent: classification.intent,\n  //     contact: contactData,\n  //     context: conversationHistory\n  //   })\n  // });\n  // if (botResponse.confidence > 0.7) {\n  //   responseText = botResponse.response;\n  //   responseType = 'bot_auto';\n  // }\n  \n  responseText = `Thank you for your message! Our AI assistant will respond shortly. (Production: Replace with actual AIgent Bot API call)`;\n  responseType = 'bot_auto';\n}\n// === DEFAULT RESPONSE ===\nelse {\n  responseText = `Thank you for contacting ${$env.CLINIC_NAME || 'us'}! A team member will respond to your message shortly.`;\n  responseType = 'default_auto';\n}\n\nreturn {\n  json: {\n    ...data,\n    response: {\n      text: responseText,\n      type: responseType,\n      generated_at: DateTime.now().toISO()\n    }\n  }\n};"
      },
      "id": "code-node-808",
      "name": "Generate Auto-Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1240, 350],
      "notes": "Create intelligent response - after-hours, intent-based, bot integration (framework)"
    },
    {
      "parameters": {
        "functionCode": "// ═══════════════════════════════════════════════════════════════\n// NODE 809: SEND RESPONSE VIA CHANNEL (CONSOLIDATED)\n// ═══════════════════════════════════════════════════════════════\n// Enhancement: Multi-channel response delivery with retry logic\n// \n// NOTE: Production should expand this into separate nodes:\n// 1. Switch by channel (SMS/WhatsApp/Email/Telegram/Webchat)\n// 2. Send SMS via Twilio (retry: 2x, 500ms)\n// 3. Send WhatsApp via Twilio (retry: 2x, 500ms)\n// 4. Send Email via SendGrid (retry: 2x, 1s)\n// 5. Send Telegram via Bot API (retry: 2x, 500ms)\n// 6. Send Webchat via Webhook (retry: 2x, 500ms)\n//\n// Each should have:\n// - retryOnFail: true\n// - maxTries: 2\n// - waitBetweenTries: 500-1000\n// - continueOnFail: false (delivery confirmation required)\n//\n// For context efficiency, this node provides the framework.\n// ═══════════════════════════════════════════════════════════════\n\nconst data = $json;\n\nconst deliveryConfig = {\n  sms: {\n    provider: 'twilio',\n    endpoint: 'https://api.twilio.com/2010-04-01/Accounts/{{ACCOUNT_SID}}/Messages.json',\n    retry_count: 2,\n    retry_delay: 500\n  },\n  whatsapp: {\n    provider: 'twilio',\n    endpoint: 'https://api.twilio.com/2010-04-01/Accounts/{{ACCOUNT_SID}}/Messages.json',\n    retry_count: 2,\n    retry_delay: 500\n  },\n  email: {\n    provider: 'sendgrid',\n    endpoint: 'https://api.sendgrid.com/v3/mail/send',\n    retry_count: 2,\n    retry_delay: 1000\n  },\n  telegram: {\n    provider: 'telegram',\n    endpoint: 'https://api.telegram.org/bot{{BOT_TOKEN}}/sendMessage',\n    retry_count: 2,\n    retry_delay: 500\n  },\n  webchat: {\n    provider: 'custom',\n    endpoint: $env.WEBCHAT_WEBHOOK_URL || 'https://example.com/webchat',\n    retry_count: 2,\n    retry_delay: 500\n  }\n};\n\nconst channelConfig = deliveryConfig[data.channel] || deliveryConfig.sms;\n\nreturn {\n  json: {\n    ...data,\n    delivery: {\n      channel: data.channel,\n      to: data.from, // Reply to original sender\n      message: data.response.text,\n      config: channelConfig,\n      status: 'pending',\n      note: 'Production: Implement actual API calls with retry logic per channel'\n    },\n    sent_at: new Date().toISOString()\n  }\n};"
      },
      "id": "code-node-809",
      "name": "Send Response (Multi-Channel Framework)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1440, 350],
      "notes": "Production: Expand into separate channel nodes (Twilio SMS/WhatsApp, SendGrid, Telegram, Webchat) with retry logic"
    },
    {
      "parameters": {
        "functionCode": "// ═══════════════════════════════════════════════════════════════\n// NODE 810: PHI MASKING FOR LOGS (ENHANCED)\n// ═══════════════════════════════════════════════════════════════\n// Enhancement: Comprehensive PHI redaction for conversation logs\n// - Mask phone numbers (partial)\n// - Mask email addresses (Level 2)\n// - Redact SSN, credit cards, medical record numbers\n// - Truncate message content (first 200 chars for preview)\n// \n// Shared Pattern: PHI Masking Level 2 (from Module 03)\n// Module-Specific: Conversation log redaction\n// PHI Level: HIGH (patient messages)\n// ═══════════════════════════════════════════════════════════════\n\nconst data = $json;\n\n// PHI masking functions\nfunction maskPhone(phone) {\n  if (!phone) return null;\n  const digits = phone.replace(/\\D/g, '');\n  if (digits.length < 4) return '****';\n  return `***-***-${digits.slice(-4)}`;\n}\n\nfunction maskEmail(email) {\n  if (!email) return null;\n  const [local, domain] = email.split('@');\n  if (!domain) return email;\n  if (local.length <= 2) return `**@${domain}`;\n  return `${local.charAt(0)}***${local.charAt(local.length - 1)}@${domain}`;\n}\n\nfunction truncateMessage(message, maxLength = 200) {\n  if (!message || message.length <= maxLength) return message;\n  return message.substring(0, maxLength) + '...';\n}\n\n// Redact sensitive patterns from message\nfunction redactMessage(message) {\n  if (!message) return '';\n  \n  let redacted = message;\n  \n  // SSN redaction\n  redacted = redacted.replace(/\\b\\d{3}-\\d{2}-(\\d{4})\\b/g, 'XXX-XX-$1');\n  \n  // Credit card redaction\n  redacted = redacted.replace(/\\b(\\d{4})\\s?\\d{4}\\s?\\d{4}\\s?(\\d{4})\\b/g, '$1 **** **** $2');\n  \n  // MRN redaction\n  redacted = redacted.replace(/\\b(?:MRN|Medical Record)[:\\s#]*(\\d{4,})\\b/gi, (match, id) => {\n    return match.replace(id, `****${id.slice(-2)}`);\n  });\n  \n  return redacted;\n}\n\n// Create masked version for logging\nconst maskedData = {\n  trace_id: data.trace_id,\n  channel: data.channel,\n  from_masked: data.channel === 'email' ? maskEmail(data.from) : maskPhone(data.from),\n  to_masked: data.channel === 'email' ? maskEmail(data.to) : maskPhone(data.to),\n  message_preview: truncateMessage(redactMessage(data.message), 200),\n  message_redacted: redactMessage(data.message),\n  classification: data.classification,\n  response_type: data.response.type,\n  timestamp: data.timestamp\n};\n\nreturn {\n  json: {\n    ...data,\n    masked_for_logging: maskedData,\n    phi_redaction_applied: true\n  }\n};"
      },
      "id": "code-node-810",
      "name": "PHI Masking for Logs",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1640, 350],
      "notes": "HIPAA-compliant redaction - phone/email masking, SSN/CC/MRN redaction, message truncation"
    },
    {
      "parameters": {
        "functionCode": "// ═══════════════════════════════════════════════════════════════\n// NODE 811: EXECUTION TIME TRACKING & BUILD OUTPUT\n// ═══════════════════════════════════════════════════════════════\n// Enhancement: Calculate execution metrics and prepare final output\n// - Total execution time\n// - Performance categorization\n// - Data Contract 08: message_log.json\n// \n// Shared Pattern: Execution Time Tracking (from Module 01)\n// Module-Specific: Message processing confirmation\n// ═══════════════════════════════════════════════════════════════\n\nconst { DateTime } = require('luxon');\nconst data = $json;\n\n// Calculate execution time\nconst executionEndTime = DateTime.now().toMillis();\nconst executionTimeMs = executionEndTime - data.execution_start_time;\n\n// Performance categorization for messaging\nlet performanceCategory = 'normal';\nif (executionTimeMs < 2000) {\n  performanceCategory = 'fast';\n} else if (executionTimeMs > 5000) {\n  performanceCategory = 'slow';\n}\n\n// Data Contract 08: message_log.json\nconst messageLog = {\n  success: true,\n  trace_id: data.trace_id,\n  message_log: {\n    direction: data.direction,\n    channel: data.channel,\n    from: data.masked_for_logging.from_masked,\n    to: data.masked_for_logging.to_masked,\n    message_preview: data.masked_for_logging.message_preview,\n    timestamp: data.timestamp\n  },\n  classification: data.classification,\n  response: {\n    type: data.response.type,\n    delivered: data.delivery?.status === 'sent' || false,\n    delivery_channel: data.channel\n  },\n  metadata: {\n    execution_time_ms: executionTimeMs,\n    performance_category: performanceCategory,\n    phi_redaction_applied: data.phi_redaction_applied,\n    processed_at: DateTime.now().toISO(),\n    module: 'aigent_module_08',\n    version: '1.1',\n    note: 'Production: Add CRM sync, Sheets logging, Staff notifications (Slack/Teams)'\n  }\n};\n\nreturn {\n  json: messageLog\n};"
      },
      "id": "code-node-811",
      "name": "Execution Tracking & Build Output",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1840, 350],
      "notes": "Calculate execution time, build message_log.json with PHI-safe data"
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{JSON.stringify($json, null, 2)}}",
        "options": {
          "responseCode": 200,
          "responseHeaders": {
            "entries": [
              {
                "name": "Content-Type",
                "value": "application/json"
              }
            ]
          }
        }
      },
      "id": "respond-node-812",
      "name": "Return: Message Processed",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [2040, 350],
      "notes": "Production: Add before this - CRM update (HubSpot), Sheets logging, Slack notifications for staff"
    }
  ],
  "pinData": {},
  "connections": {
    "Webhook: Unified Message Receiver": {
      "main": [
        [
          {
            "node": "Normalize Message Format",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Normalize Message Format": {
      "main": [
        [
          {
            "node": "Enhanced Validation",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Enhanced Validation": {
      "main": [
        [
          {
            "node": "Validation Passed?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validation Passed?": {
      "main": [
        [
          {
            "node": "Classify Message Intent",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Validation Error Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validation Error Response": {
      "main": [
        [
          {
            "node": "Return: Validation Error",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Classify Message Intent": {
      "main": [
        [
          {
            "node": "Generate Auto-Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Auto-Response": {
      "main": [
        [
          {
            "node": "Send Response (Multi-Channel Framework)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Send Response (Multi-Channel Framework)": {
      "main": [
        [
          {
            "node": "PHI Masking for Logs",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "PHI Masking for Logs": {
      "main": [
        [
          {
            "node": "Execution Tracking & Build Output",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Execution Tracking & Build Output": {
      "main": [
        [
          {
            "node": "Return: Message Processed",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "1",
  "meta": {
    "module": "aigent_module_08",
    "version": "1.1",
    "description": "Enhanced omnichannel messaging hub with intelligent routing, intent classification, PHI-safe logging, and multi-channel support",
    "author": "Aigent System",
    "created": "2025-01-XX",
    "phi_level": "HIGH",
    "dependencies": ["module_02", "module_04"],
    "integrations": ["twilio", "sendgrid", "telegram", "hubspot"],
    "channels": ["sms", "whatsapp", "email", "telegram", "webchat"],
    "note": "Production: Expand into full 32-node workflow with CRM lookup/create, AIgent Bot API, channel-specific delivery nodes with retry logic, Slack notifications, Google Sheets logging"
  },
  "id": "module-08-enhanced",
  "tags": []
}
